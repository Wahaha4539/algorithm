### 题目一
``` 
一棵二叉树原本是搜索二叉树，但是其中有两个节点调换了位置，使得这棵二叉树不再是搜索二叉树，
请找到这两个错误节点并返回。已知二叉树中所有节点的值都不一样，给定二叉树的头节点head，
返回一个长度为2的二叉树节点类型的数组errs，errs［0］表示一个错误节点，errs［1］表示另一个错误节点。

进阶：如果在原问题中得到了这两个错误节点，我们当然可以通过交换两个节点的节点值的方式让整棵二叉树重新成为搜索二叉树。
但现在要求你不能这么做，而是在结构上完全交换两个节点的位置，请实现调整的函数
```

中序遍历 第一次的第一个节点 和 第二次降序的第二个节点

### 题目二

``` 
给定一个非负数组arr，和一个正数m
返回arr的所有子序列中累加和％m之后的最大值。
```

### 题目三

``` 
项目有四个信息：
1）哪个项目经理提的
2）被项目经理润色出来的时间点
3）项目优先级
4）项目花费的时间
项目经理们可以提交项目给程序员们，程序员可以做这些项目。
比如长度为4的数组［1，3，2，2］，表示1号项目经理提的，被项目经理润色出来的时间点是3，优先级2，花费程序员2个时间。所以给一个N＊4的矩阵，就可以代表N个项目。
给定一个正数pm，表示项目经理的数量，每个项目经理只负责自己的那些项目，并且一次只能提交一个项目给程序员们，这个提交的项目做完了，才能再次提交。
经理对项目越喜欢，就会越早提交。一个项目优先级越高越被喜欢；如果优先级一样，花费时间越少越喜欢；如果还一样，被项目经理润色出来的时间点越早越喜欢。
给定一个正数sde，表示程序员的数量，所有经理提交了的项目，程序员会选自己喜欢的项目做，每个人做完了一个项目，然后才会再来挑选。
当程序员在挑选项目时，有自己的喜欢标准。一个项目花费时间越少越被喜欢；如果花费时间一样，该项自的负责人编号越小越被喜欢。
返回一个长度为N的数组，表示N个项目的结束时间。
比如：
int pms=2; int sde=2;
int[][] programs = {{ 1, 1, 1, 2 }, { 1, 2, 1, 1 }.{1,3,2,2},{2,1,1,2},{2,3,5,5}};
返回｛3，4，5，3，9｝
```
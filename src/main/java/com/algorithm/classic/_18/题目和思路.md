### 题目一

```
给定一个二维数组matrix，每个单元都是一个整数，有正有负。
最开始的时候小Q操纵一条长度为0的蛇蛇从矩阵最左侧任选一个单元格进入地图，
蛇每次只能够到达当前位置的右上相邻，右侧相邻和右下相邻的单元格。
蛇蛇到达一个单元格后，自身的长度会瞬间加上该单元格的数值，任何情况下长度为负则游戏结束。
小Q是个天才，他拥有一个超能力，可以在游戏开始的时候把地图中的某一个节点的值变为其相反数（注：最多只能改变一个节点）。
问在小Q游戏过程中，他的蛇蛇最长长度可以到多少？
比如：       
            1 -4  10 
            3 -2  -1 
            2 -1  0 
            0  5  -2

最优路径为从最左侧的3开始，3—＞—4（利用能力变成4）—＞10。所以返回17。
```

业务限制模型<br/>
业务表达抽象 递归能力<br/>

code **SnakeGame**


### 题目二

```
给定一个字符串str，求最长回文子序列长度
```

1. 与逆序串的最长公共子序列 
2. 范围尝试的动态规划
   ```
   (L,L) 1
   (L, L + 1) str[L] == str[L + 1] ? 2 : 1
   普通位置
      [L, R] 1. L x, R x  ---> dp[L + 1][R - 1]
             2. L x, R ✓  ---> dp[L + 1][R]
             3. L ✓, R x  ---> dp[L][R-1]
             4. L  , R    --->  前提条件是str[L] == str[R] dp[L + 1] + dp[R - 1] + 2
   ```


### 题目三

``` 
给定一个字符串str，str表示一个公式，公式里可能有整数、加减乘除符号和左右括号，返回公式的计算结果。
【举例】
str="48*((70-65)-43)+8*1",返回-1816。
str＝＂3＋1＊4＂，返回7。
str＝＂3＋（1＊4）＂，返回7。
【说明】
1．可以认为给定的字符串一定是正确的公式，即不需要对str做公式有效性检查。
2．如果是负数，就需要用括号括起来，比如“4＊（-3）＂。但如果负数作为公式的开头或括号部分的开头，则可以没有括号，比如＂-3＊4＂和＂（-3＊4）＂都是合法的。
3．不用考虑计算过程中会发生溢出的情况。
```

如果没有括号，该怎么计算？
利用栈: 先压栈 压栈过程中 如果栈顶元素是* 或者 / 则pop出2个元素 与当前值计算后得出结果放入栈中(意思是将* / 先计算了 作为一个元素放入栈中)


有括号:
f(i): i以及往后到合适位置的值(结尾/第一个右括号)

code **ExpressionCompute**

### 题目四

``` 
对于一个字符串，从前开始读和从后开始读是一样的，我们就称这个字符串是回文串。
例如“ABCBA”，“AA”，“A”是回文串，而＂ABCD＂， ＂AAB＂不是回文串。
牛牛特别喜欢回文串，他手中有一个字符串s，牛牛在思考能否从字符串中移除部分（0个或多个）字符使其变为回文串，
并且牛牛认为空串不是回文串。牛牛发现移除的方案可能有很多种，希望你来帮他计算一下一共有多少种移除方案可以使s变为回文串。
对于两种移除方案，如果移除的字符依次构成的序列不一样就是不同的方案。
例如，XXY 4种 ABA 5种
【说明】这是今年的原题，提供的说明和例子都很让人费解。现在根据当时题目的所有测试用例，重新解释当时的题目含义：
1）＂1AB23CD21＂，你可以选择删除A、B、C、D，然后剩下子序列｛1，2，3，2，1｝，
只要剩下的子序列是同一个，那么就只算1种方法，和A、B、C、D选择什么样的删除顺序没有关系。
2）“121A1”，其中有两个｛1，2，1｝的子序列，第一个｛1，2，1｝是由｛位置0，位置1，位置2｝构成，
第二个｛1，2，1｝是由｛位置0，位置1，位置4｝构成。这两个子序列被认为是不同的子序列。
也就是说在本题中，认为字面值一样但是位置不同的字符就是不同的。
3）其实这道题是想求，str中有多少个不同的子序列，每一种子序列只对应一种删除方法，那就是把多余的东 西去掉，而和去掉的顺序无关。
4）也许你觉得我的解释很荒谬，但真的是这样，不然解释不了为什么，XXY4种ABA 5种，而且其他的测试用例都印证了这一点。
```
范围尝试模型

dp[i][j] i..j 上有多少方案成为回文

(L,R) x 代表不要 ✓ 代表要
分为4种可能
``` 
a L x R x
b L x R ✓
c L ✓ R x
d L x R x str[L] == str[R]
```
``` 
dp[L + 1][R] 含义是啥: L x  R x  和 L x R ✓ =a + b
dp[L][R - 1] 含义是啥: L x  R x  和 L ✓ R x =a + c
dp[L+1][R - 1] 含义是啥: L x R x = a
a + b + c = (a + b) + (a + c) - (a) = dp[L + 1][R] + dp[L][R - 1] - dp[L+1][R - 1]
如果str[L] == str[R] 那么 d = dp[L+1][R - 1]+1  +1 是因为L+1, R-1 成为空串的一种可能
```

code **PalindromeWays**
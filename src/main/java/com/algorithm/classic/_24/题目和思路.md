### 题目一
``` 
一个缓存结构需要实现如下功能
void set（int key， int value）：加入或修改key对应的value 
int get（int key）：查询key对应的value值
但是缓存中最多放K条记录，如果新的第K＋1条记录要加入，就需要根据策略删掉一条记录，然后才能把新记录加入。

这个策略为：
在缓存结构的K条记录中，哪一个key从进入缓存结构的时刻开始，被调用set或者get的次数最少，就删掉这个key的记录；
如果调用次数最少的key有多个，上次调用发生最早的key被删除。这就是LFU缓存替换算法。实现这个结构，K作为参数给出。
```

二维双向链表

Bucket  Node

单个Bucket:  Node <-> Node
Bucket < -- > Bucket

### 题目二
``` 
给定一个数组arr，给定一个正数k。
选出3个不重叠的子数组，每个子数组长度都是k，返回最大的三子数组的最大和。
```

dp[i] arr[0...i] 必须k个子数组最大值

dp`[i] arr[i...N-1] 必须k个子数组最大值

固定中间位置, 一个循环, 取最大值


### 题目三

``` 
一群孩子做游戏，现在请你根据游戏得分来发糖果，要求如下：
1．每个孩子不管得分多少，起码分到1个糖果。
2．任意两个相邻的孩子之间，得分较多的孩子必须拿多一些的糖果。
给定一个数组arr代表得分数组，请返回最少需要多少糖果。
例如：arr＝［1，2，2］，糖果分配为［1，2，1］．
即可满足要求且数量最少，所以返回4。
【进阶】

原题目中的两个规则不变，再加一条规则：
3．任意两个相邻的孩子之间如果得分一样，糖果数必须相同。
给定一个数组arr代表得分数组，返回最少需要多少糖果。
例如:arr=[1,2,2]，
糖果分配为［1，2，2］即可满足要求且数量最少，所以返回5。
【要求】
arr长度为N，原题与进阶题都要求时间复杂度为O（N），额外空间复杂度为0（1）。
```

### 题目四
``` 
给定一棵二叉树的头节点head，如果在某一个节点x上放置相机，
那么x的父节点、x的所有子节点以及x都可以被覆盖。
返回如果要把所有数都覆盖，至少需要多少个相机。
```